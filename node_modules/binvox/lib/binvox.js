/**
 * binvox v1.1.0 build Sun Apr 26 2020
 * https://github.com/andstor/binvox
 * Copyright 2020 Andr√© Storhaug, MIT
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.BINVOX = {}));
}(this, (function (exports) { 'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  /**
   * @typedef {Object} Voxel The actual voxel data, describing a filled voxel.
   * @property {number} x The x coordinate of the voxel.
   * @property {number} y The y coordinate of the voxel.
   * @property {number} z The z coordinate of the voxel.
   */

  /**
   * @typedef {Object} VoxelData Parsed BINVOX file data structure representation.
   * @property {Object} dimension The dimension of the voxel data.
   * @property {number} dimension.depth The depth dimension of the voxel data.
   * @property {number} dimension.width The width dimension of the voxel data.
   * @property {number} dimension.height The height dimension of the voxel data.
   * @property {Object} translate The translation of the voxel data.
   * @property {number} translate.depth The depth translation of the voxel data.
   * @property {number} translate.width The width translation of the voxel data.
   * @property {number} translate.height The height translation of the voxel data.
   * @property {number} scale The scaling of the voxel data.
   * @property {Array<Voxel>} voxels The actual voxel data, describing filled voxels.
   */

  /**
   * Parser for parsing BINVOX voxel file data.
   */
  var Parser = /*#__PURE__*/function () {
    /**
     * Creates a BINVOX Parser.
     */
    function Parser() {
      _classCallCheck(this, Parser);

      this.dimension = {};
      this.translation = {};
      this.scale = 1;
      this.voxels = [];
      this.index = 0;
    }
    /**
     * Parse BINVOX file buffer data.
     * @param {ArrayBuffer} buffer BINVOX buffer data.
     * @returns {VoxelData} The parsed voxel data.
     */


    _createClass(Parser, [{
      key: "parse",
      value: function parse(buffer) {
        this._parseHeader(buffer);

        this._parseVoxelData(buffer);

        return {
          dimension: this.dimension,
          translate: this.translation,
          scale: this.scale,
          voxels: this.voxels
        };
      }
      /**
       * Parse the BINVOX ASCII file header.
       * @param {ArrayBuffer} buffer BINVOX file buffer data.
       * @private
       */

    }, {
      key: "_parseHeader",
      value: function _parseHeader(buffer) {
        var decoder = new TextDecoder('ascii');
        var continueReading = true;
        var lines = [];
        var i = this.index;
        var line = "";

        while (continueReading) {
          var _char = decoder.decode(buffer.slice(i, i + 1));

          if (_char === "\n") {
            lines.push(line);
            line = "";
          } else {
            line += _char;
          }

          if (line === "Data" || lines.length >= 5) {
            continueReading = false;
          }

          i++;
        }

        this.index = i;
        var version = lines[0];
        var dimension = lines[1];
        var translate = lines[2];
        var scale = lines[3];
        var data = lines[4]; // Check "version" line

        if (version !== "#binvox 1") {
          throw new Error("First line reads \"" + version + "\" instead of \"#binvox\"");
        } // Parse "dimension"


        var dimensionArray = dimension.split(" ");

        if (dimensionArray[0] !== "dim") {
          throw new Error("Error reading dimension line");
        }

        this.dimension = {
          depth: parseInt(dimensionArray[1]),
          width: parseInt(dimensionArray[2]),
          height: parseInt(dimensionArray[3])
        }; // Parse "translation"

        var translateArray = translate.split(" ");

        if (translateArray[0] !== "translate") {
          throw new Error("Error reading translate line");
        }

        this.translation = {
          depth: parseFloat(translateArray[1]),
          width: parseFloat(translateArray[2]),
          height: parseFloat(translateArray[3])
        }; // Parse "scale"

        var scaleArray = scale.split(" ");

        if (scaleArray[0] !== "scale") {
          throw new Error("Error reading scale line");
        }

        this.scale = parseFloat(scaleArray[1]); // Check "data" line

        if (data !== "data") {
          throw new Error("Error reading header");
        }
      }
      /**
       * Parse the voxel buffer data.
       * @param {ArrayBuffer} buffer BINVOX file voxel buffer data.
       * @private
       */

    }, {
      key: "_parseVoxelData",
      value: function _parseVoxelData(buffer) {
        var int8view = new Uint8Array(buffer, this.index);
        var i = 0;
        var y = 0;
        var z = 0;
        var x = 0;

        while (i < int8view.length) {
          var value = int8view[i];
          var count = int8view[i + 1];

          for (var j = 0; j < count; j++) {
            if (value === 1) {
              var point = {
                x: x,
                y: y,
                z: z
              };
              this.voxels.push(point);
            }

            y++;

            if (y === this.dimension.width) {
              y = 0;
              z++;
            }

            if (z === this.dimension.height) {
              z = 0;
              x++;
            }
          }

          i += 2;
        }
      }
    }]);

    return Parser;
  }();

  /**
   * Builder for making BINVOX buffer data.
   */
  var Builder = /*#__PURE__*/function () {
    /**
     * Creates a new BINVOX Builder.
     */
    function Builder() {
      _classCallCheck(this, Builder);

      this.dimension = {};
      this.translation = {};
      this.scale = 1;
      this.voxels = [];
    }
    /**
     * Build BINVOX file buffer data.
     * @param {VoxelData} data JavaScript representation of BINVOX voxel data.
     */


    _createClass(Builder, [{
      key: "build",
      value: function build(data) {
        this.dimension = data.dimension;
        this.translation = data.translate;
        this.scale = data.scale;
        this.voxels = data.voxels;

        var headerTArray = this._generateHeader();

        var voxelsTArray = this._generateVoxelData(); // Concatenate the two typed arrays.


        var binvoxArray = new Uint8Array(headerTArray.length + voxelsTArray.length);
        binvoxArray.set(headerTArray);
        binvoxArray.set(voxelsTArray, headerTArray.length);
        return binvoxArray.buffer;
      }
      /**
       * Generate the ASCII BINVOX file header.
       * @private
       */

    }, {
      key: "_generateHeader",
      value: function _generateHeader() {
        var encoder = new TextEncoder('ascii');
        var header = "";
        header += "#binvox 1\n";
        header += "dim " + [this.dimension.depth, this.dimension.width, this.dimension.height].join(" ") + "\n";
        header += "translate " + [this.translation.depth, this.translation.width, this.translation.height].join(" ") + "\n";
        header += "scale " + this.scale + "\n";
        header += "data\n";
        return encoder.encode(header);
      }
      /**
       * Generate the binary voxel data.
       * @private
       */

    }, {
      key: "_generateVoxelData",
      value: function _generateVoxelData() {
        var index = 0;
        var count = 0;
        var state;

        if (this.voxels[0].x === 0 && this.voxels[0].y === 0 && this.voxels[0].z === 0) {
          state = 1;
        } else {
          state = 0;
        }

        var array = [];

        for (var i = 0; i < this.dimension.depth; i++) {
          for (var j = 0; j < this.dimension.height; j++) {
            for (var k = 0; k < this.dimension.width; k++) {
              var value = 0;

              if (this.voxels[index] !== undefined && this.voxels[index].x === i && this.voxels[index].y === k && this.voxels[index].z === j) {
                index++;
                value = 1;
              }

              if (value === state) {
                count++;

                if (count === 255) {
                  // Max count encountered!
                  array.push(state, count);
                  count = 0;
                }
              } else {
                // Switch in state detected!
                array.push(state, count);
                state = value;
                count = 1;
              }
            }
          }
        } // Handle remaining.


        if (count > 0) {
          array.push(state, count);
        }

        return new Uint8Array(array);
      }
    }]);

    return Builder;
  }();

  exports.Builder = Builder;
  exports.Parser = Parser;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=binvox.js.map
